# Вопросы к собеседованию на позицию разработчик JavaScript (junior):
___

## 1. Типы данных и расширенные выражения

### Вопрос: Какие типы данных существуют в JavaScript?
### Ответ:
JavaScript поддерживает восемь основных типов данных:

7 простых:
- **String:** Последовательность символов, заключенная в кавычки.
- **Number:** Числовые значения, включая целые числа и числа с плавающей точкой.
- **BigInt:** Большие целые числа произвольной длины.
- **Boolean:** Логические значения true или false.
- **Undefined:** Значение, назначаемое переменной, которая была объявлена, но не инициализирована.
- **Null:** Специальное значение, обозначающее отсутствие какого-либо объекта.
- **Symbol:** Уникальное значение, используемое для создания уникальных идентификаторов.

1 ссылочный тип:
- **Object:** Коллекция свойств и методов, включая массивы, функции и объекты.

### Вопрос: В чем разница между простыми и ссылочным типом данных?
### Ответ:
Простые типы данных:
- Представляют собой одиночные значения.
- Передаются по значению.
- Копируются при передаче.

Ссылочный тип данных (Object):
- Представляет коллекцию данных.
- Передается по ссылке.
- Изменения в одном экземпляре отражаются во всех ссылках на этот объект.

### Вопрос: Чем отличается Object.is() от == и ===?
### Ответ:
- **==** выполняет приведение типов: 5 == '5' → true.
- **===** строгое равенство без приведения: 5 === '5' → false.
- **Object.is()** работает как **===**, но с особыми случаями:

```javascript

    Object.is(NaN, NaN) // true
    Object.is(0, -0)    // false
    
```

#### Пример:
```javascript

    // Пример с ==
    console.log(5 == '5');     // true (приведение типов)
    console.log(5 == 5);        // true
    
    // Пример с ===
    console.log(5 === '5');     // false (строгое сравнение)
    console.log(5 === 5);        // true
    
    // Пример с Object.is()
    console.log(Object.is(NaN, NaN));           // true
    console.log(Object.is(0, -0));              // false
    console.log(Object.is({ a: 1 }, { a: 1 })); // false (сравнение ссылок)

```

### Вопрос: В чем разница между let, var и const?
### Ответ:
- **var:** имеет функциональную область видимости, подвержена подъему (hoisting), возможна повторная инициализация.
- **let/const:** имеют блочную область видимости, не подвержены подъему, поддержка временных мертвых зон (TDZ).
- **const:** значение нельзя изменить после присвоения, однако объект или массив, объявленный через const, можно изменять (мутировать).

### Можно уточнить про временную мертвую зону (TDZ):
### Вопрос: Что такое TDZ в JavaScript?
### Ответ:
**TDZ (Temporal Dead Zone)** — это зона, в которой переменная объявлена, но еще не инициализирована. Доступ к такой переменной вызывает ошибку ReferenceError.

#### Пример TDZ:
```javascript

   console.log(a); // ReferenceError: Cannot access 'a' before initialization
   let a = 5;
   
```

### Как избежать TDZ:
Всегда объявлять и инициализировать let/const до использования:

```javascript

    let a = 5; // Корректно
    console.log(a); // 5
    
```

### Вопрос: Что такое полифиллы?
### Ответ: 
**Полифилл** — это фрагмент кода, который добавляет поддержку новой функциональности в старые версии браузера или среды исполнения. Например, реализация метода Array.prototype.flat для Internet Explorer.

___

## 2. Области видимости
### Вопрос: Какие области видимости существуют в JavaScript?
### Ответ:
- **глобальная область видимости:** переменные, объявленные вне всех функций и блоков.
- **функциональная область видимости:** переменные, объявленные внутри функции с помощью var.
- **блочная область видимости:** переменные, объявленные внутри блока {...} с помощью let или const.
- **лексическая область видимости:** связана с областью определения функции и используется для замыкания.

#### Пример:
```javascript

    // Глобальная переменная
    var globalVar = 'global';
    
    function foo() {
        // Локальная переменная (функциональная область видимости)
        var funcVar = 'function';
    
        if (true) {
            // Локальная переменная (блочная область видимости)
            let blockVar = 'block';
    
            console.log(globalVar); // 'global' (доступна)
            console.log(funcVar);   // 'function' (доступна)
            console.log(blockVar);  // 'block' (доступна)
        }
    
        // За пределами блока
        console.log(blockVar); // ReferenceError: blockVar is not defined (недоступна)
    }
    
    foo();

```
___

## 3. Функции

### Вопрос:  Какие функции есть в javascript.
### Ответ:
- объявление функции (function declaration).
```javascript

    function greet(name) {
        console.log(`Привет, ${name}`);
    }
    
```
В данном случае функция объявляется с помощью ключевого слова function, после которого идет имя функции (greet) и список аргументов в скобках. Это традиционный способ объявления функций в JavaScript.

- выражение функции (function expression).
```javascript

    const greet = function(name) {
        console.log(`Привет, ${name}`);
    };

```
Здесь функция создается как анонимная функция, которую мы присваиваем переменной greet. Такой подход позволяет использовать функции как значения, что полезно при работе с функциями высшего порядка.

- arrow function (стрелочные функции)
```javascript

    const greet = (name) => {
        console.log(`Привет, ${name}`);
    };

```
Стрелочные функции были введены в ES6 и позволяют писать код короче и лаконичнее. Они особенно удобны для коротких выражений и часто используются в функциях обратного вызова и массивных методах вроде .map(), .filter() и .reduce().

### Вопрос: В чем разница между function declaration, function expression и стрелочными функциями?
### Ответ:

#### Function Declaration (Объявление функции)
- **поднятие (hoisting):** полностью поднимается в начало области видимости, можно вызывать до объявления.
- **контекст (this):** имеет собственный динамический this.
- **доступ к arguments:** eсть.
- **использование как конструктор:** можно (через new).

#### Синтаксис:
```javascript

    console.log(sum(2, 3)); // 5 (работает из-за hoisting)
    function sum(a, b) { return a + b; }

```

#### Function Expression (Функциональное выражение)
- **поднятие (hoisting):** поднимается только переменная (не сама функция), вызов до объявления вызовет ошибку.
- **контекст (this):** имеет собственный динамический this.
- **доступ к arguments:** eсть.
- **использование как конструктор:** можно (через new).

#### Синтаксис:
```javascript

    console.log(sub(5, 2)); // Ошибка (ReferenceError)
    const sub = function(a, b) { return a - b; };

```

#### Стрелочная функция (Arrow Function)
- **поднятие (hoisting):** не поднимается.
- **контекст (this):** не имеет своего this, берет из внешней области видимости (лексический this).
- **доступ к arguments:** нет (используйте rest-параметры ...args).
- **использование как конструктор:** Нельзя (вызов с new вызовет ошибку):

#### Синтаксис:
```javascript

    const mult = (a, b) => a * b;
    console.log(mult(2, 4)); // 8

```

### Ключевые отличия:
**Поднятие:**
- function declaration — можно вызывать до объявления.
- function expression / стрелочные — нельзя.

**this:**
- обычные функции (declaration/expression) — свой this (зависит от вызова).
- стрелочные — нет своего this, берут из внешнего контекста.

**arguments:**
- обычные функции — есть.
- стрелочные — нет (используйте ...args).

**конструкторы:**
- обычные функции — можно использовать с new.
- стрелочные — нельзя.

### Примеры работы с конструктором:
Обычная функция (можно использовать как конструктор):
```javascript

    function Person(name) {
        this.name = name;
    }
    
    const john = new Person("John");
    console.log(john.name); // "John"

```
Стрелочная функция (нельзя использовать как конструктор):
```javascript

    const Person = (name) => {
        this.name = name; // Ошибка: "this" не определен в стрелочной функции
    };
    
    const jane = new Person("Jane"); // TypeError: Person is not a constructor

```

### Вопрос: Как работают параметры по умолчанию?
### Ответ:
Параметры по умолчанию позволяют задать начальные значения для аргументов функции, если они не переданы при вызове.

#### Пример:
```javascript

    function greet(name = 'Guest') {
        console.log(`Hello, ${name}`);
    }
    
    greet(); // Hello, Guest
    
```

### Вопрос: В чем разница между arguments и rest-параметрами (...)?
### Ответ: 
- **arguments:** псевдо-массив, доступный во всех обычных функциях (кроме стрелочных), содержит все переданные аргументы, включая избыточные.
- **rest-параметры** (...args): настоящий массив, содержащий только оставшиеся аргументы, которые не были захвачены именованными параметрами.

### Примеры:
```javascript

   // Arguments
    function logArguments() {
        console.log(arguments); // Псевдо-массив: { 0: 1, 1: 2, 2: 3, length: 3 }
    }
    
    logArguments(1, 2, 3);

    // Rest-параметры
    function logRest(first, second, ...rest) {
        console.log(rest); // Массив: [3, 4]
    }
    
    logRest(1, 2, 3, 4);

```
___

## 4. Замыкания и this

### Вопрос: Что такое замыкание?
### Ответ:
Замыкание — это комбинация функции и лексического окружения, в котором эта функция была создана. Оно позволяет функции "запоминать" внешние переменные, даже когда выполнение вышел за пределы той области видимости, где эти переменные были определены.

#### Пример:
```javascript

    function createCounter() {
        let count = 0;
        return function increment() {
            return ++count;
        };
    }
    
    const counter = createCounter();
    
    console.log(counter()); // 1
    console.log(counter()); // 2
    console.log(counter()); // 3

```

### Вопрос: Как работает управление this?
### Ответ:
Контекст this в JavaScript зависит от способа вызова функции, чтобы зафиксировать или изменить контекст, можно использовать следующие методы:

- **bind:** создает новую функцию с жестко зафиксированным контекстом this.
- **call:** вызывает функцию немедленно с указанным контекстом this.
- **apply:** то же самое, что call, но принимает аргументы в виде массива.

#### Пример:
```javascript

    function greet() {
        console.log(`Hello, ${this.name}`);
    }
    
    const person = { name: 'Alex' };
    
    greet.call(person);      // Hello, Alex
    
    const boundGreet = greet.bind(person);
    boundGreet();            // Hello, Alex

```

### Вопрос: Почему this в стрелочных функциях берется из окружающей области видимости?
### Ответ: 
Стрелочные функции не создают свой собственный контекст this. Вместо этого они используют this из окружающей области видимости (лексический this), что делает их полезными в ситуациях, когда нужно сохранить контекст родителя.

#### Пример: 
```javascript

    const obj = {
        name: 'John',
        method: function() {
            setTimeout(() => {
                console.log(this.name); // 'John' (берётся из obj)
            });
        }
    };
    
    obj.method(); // 'John'

```
В этом примере, несмотря на то, что setTimeout создаёт новый контекст выполнения, стрелочная функция всё равно использует this из родительской функции method.

### Дополнительные аспекты:
### Вопрос: Что такое лексическое окружение?
**Лексическое окружение** — это внутреннее представление контекста выполнения функции, которое включает в себя:
- Локальные переменные.
- Параметры функции.
- Внешнюю ссылку на родительское окружение.

#### Пример:
```javascript

    function outer() {
        let x = 10;
        function inner() {
            console.log(x); // 10
        }
        inner();
    }
    
    outer();

```

### Заключение:
- замыкания важны для сохранения состояния и управления доступом к данным.
- управление this критично для понимания работы методов объектов и контекста выполнения функций.

___ 

## 5. Встроенные методы объектов

### Вопрос: Как использовать Object.keys и Object.values?
### Ответ:
Методы Object.keys и Object.values позволяют извлекать ключи и значения соответственно из объектов.

#### Пример:
```javascript

    const person = {
        name: 'John',
        age: 30,
        city: 'New York'
    };
    
    console.log(Object.keys(person)); // ['name', 'age', 'city']
    console.log(Object.values(person)); // ['John', 30, 'New York']

```

### Вопрос: Что такое флаги и дескрипторы свойств?
### Ответ:
Флаги и дескрипторы свойств позволяют контролировать поведение свойств объектов, такие как доступ к ним, изменение и удаление.

#### Пример:
```javascript

    const person = {
        name: 'John',
        age: 30
    };
    
    Object.defineProperty(person, 'isAdult', {
        get: function() {
            return this.age >= 18;
        },
        configurable: true,
        enumerable: true
    });
    
    console.log(person.isAdult); // true

```

### Вопрос: Как использовать вычисляемые свойства объекта?
### Ответ:
Вычисляемые свойства позволяют динамически определять имена свойств объектов на основе выражений.

#### Пример:
```javascript

    const key = 'name';
    const person = {
        [key]: 'John',
        age: 30
    };
    
    console.log(person.name); // 'John'

```

### Вопрос: Как перебирать пары ключ-значение в объектах?
### Ответ:
Метод Object.entries позволяет перебирать пары ключ-значение в объектах.

#### Пример:
```javascript

    const person = {
        name: 'John',
        age: 30,
        city: 'New York'
    };
    
    for (const [key, value] of Object.entries(person)) {
        console.log(`${key}: ${value}`); // name: John, age: 30, city: New York
    }

```
___

## 6. Встроенные методы массивов

### Вопрос: Как копировать и модифицировать массивы?
### Ответ:
Для копирования и модификации массивов в JavaScript предусмотрены методы slice, splice и concat. Рассмотрим их подробнее:

- **slice(start, end):** возвращает копию части исходного массива, начиная с индекса start и заканчивая индексом end (не включительно). Не изменяет оригинальный массив.
- **splice(index, deleteCount, ...items):** изменяет содержимое массива, удаляя существующие элементы и/или вставляя новые. Может возвращать удалённые элементы.
- **concat(array1, array2, ..., arrayN):** соединяет два или более массивов и возвращает новый массив.

#### Пример:
```javascript

    const arr1 = [1, 2, 3];
    const arr2 = arr1.slice(); // Копия массива
    arr2.push(4); // Модификация копии
    
    console.log(arr1); // [1, 2, 3]
    console.log(arr2); // [1, 2, 3, 4]

```

### Вопрос: Как выравнивать вложенные массивы?
### Ответ:
Метод flat(depth) позволяет выравнивать многомерные массивы, уменьшая уровень вложенности. Глубина выравнивания задаётся параметром depth (по умолчанию 1).

#### Пример:
```javascript

    const nestedArr = [[1, 2], [3, 4]];
    const flattenedArr = nestedArr.flat();
    
    console.log(flattenedArr); // [1, 2, 3, 4]

```

### Вопрос: Как сортировать массивы?
### Ответ:
Метод sort(compareFunction) сортирует элементы массива. По умолчанию сортирует в порядке ASCII-кодировки символов, пользовательская функция сравнения позволяет настроить сортировку по любому критерию.

#### Пример:
```javascript

    const numbers = [3, 1, 4, 2];
    numbers.sort((a, b) => a - b); // Сортируем по возрастанию
    console.log(numbers); // [1, 2, 3, 4]

```

### Вопрос: Как фильтровать элементы массива?
### Ответ:
Метод filter(callback) позволяет отфильтровывать элементы массива на основе условия, заданного в колбэк-функции. Возвращает новый массив, состоящий из тех элементов, для которых колбэк-функция вернула true.

#### Пример:
```javascript

    const numbers = [1, 2, 3, 4, 5];
    const evenNumbers = numbers.filter(num => num % 2 === 0);
    
    console.log(evenNumbers); // [2, 4]

```
___

## 7. ECMAScript

### Вопрос: Как работает деструктуризация?
### Ответ:
Деструктуризация позволяет извлекать данные из объектов и массивов удобным способом. Она значительно упрощает извлечение значений и назначение их переменным.

```javascript

    const [a, b] = [1, 2]; // a=1, b=2
    
    const { name } = { name: 'John' }; // name='John'
    
```

### Вопрос: Для чего нужен Symbol.iterator?
### Ответ: 
Symbol.iterator используется для создания перебираемых объектов. Он позволяет объектам участвовать в циклах for...of и других итерационных операциях.

### Пример:
```javascript
    
    const range = {
        from: 1,
        to: 3,
        [Symbol.iterator]() {
            let current = this.from;
            return { next: () => ({ value: current++, done: current > this.to + 1 }) };
        }
    };
    
    for (let num of range) { 
        console.log(num); // 1, 2, 3
    }
        
```

### Вопрос: Что такое spread оператор?
### Ответ:
Spread оператор (...) позволяет "развернуть" элементы массива или свойства объекта. Он полезен для копирования массивов, объединения объектов и передачи аргументов в функции.

#### Пример:
```javascript

    // Копирование массива
    const arr1 = [1, 2, 3];
    const arr2 = [...arr1, 4, 5]; // arr2 = [1, 2, 3, 4, 5]
    
    // Объединение объектов
    const obj1 = { a: 1, b: 2 };
    const obj2 = { ...obj1, c: 3 }; // obj2 = { a: 1, b: 2, c: 3 }
    
    // Передача аргументов в функцию
    function sum(...nums) {
        return nums.reduce((acc, curr) => acc + curr, 0);
    }
    
    console.log(sum(1, 2, 3, 4)); // 10

```

### Вопрос: Что такое шаблоны строк?
### Ответ:
Шаблонные строки (template literals) позволяют встраивать выражения в строку, используя символы ${}. Это упрощает создание сложных строковых литералов.

#### Пример:
```javascript

    const name = 'John';
    const age = 30;
    
    console.log(`My name is ${name} and I am ${age} years old.`); // My name is John and I am 30 years old.

```

### Вопрос: Что такое Set и Map в JavaScript?
### Ответ:
- **Set:** Это коллекция уникальных значений любого типа. Элементы Set не могут дублироваться.
- **Map:** Это коллекция пар ключ-значение, где ключ может быть любого типа. В отличие от обычных объектов, ключи в Map могут быть не только строками.
#### Пример:
```javascript

    // Set
    const set = new Set([1, 2, 3]);
    set.add(4);
    console.log(set.has(3)); // true
    console.log(set.size); // 4
    
    // Map
    const map = new Map([
        ["apple", 5],
        ["banana", 10]
    ]);
    map.set("cherry", 15);
    console.log(map.get("apple")); // 5
    console.log(map.size); // 3

```

### Вопрос: Чем отличаются Set и Map от обычных массивов и объектов?
### Ответ:
**Set:**
- Не допускает дублирования элементов.
- Подходит для быстрого поиска и проверки наличия элементов.
- Поддерживает итеративные методы, такие как forEach.

**Map:**
- Ключи могут быть любого типа (включая объекты).
- Более гибкая альтернатива обычному объекту.
- Легко отслеживает количество записей с помощью свойства size.
#### Пример:
```javascript

    // Объекты vs Map
    const obj = {};
    obj["apple"] = 5;
    obj["banana"] = 10;
    console.log(obj.apple); // 5
    
    const map = new Map();
    map.set("apple", 5);
    map.set("banana", 10);
    console.log(map.get("apple")); // 5

```

### Вопрос: Что такое WeakSet и WeakMap?
### Ответ:
- **WeakSet:** Это коллекция объектов, которые могут быть собраны сборщиком мусора, если на них больше нет внешних ссылок.
- **WeakMap:** Это коллекция пар ключ-значение, где ключ обязательно должен быть объектом. Значения могут быть собраны сборщиком мусора, если на ключ больше нет внешних ссылок.
#### Пример:
```javascript

    // WeakSet
    const weakSet = new WeakSet();
    const obj1 = { id: 1 };
    weakSet.add(obj1);
    console.log(weakSet.has(obj1)); // true
    
    // WeakMap
    const weakMap = new WeakMap();
    const key1 = { id: 1 };
    weakMap.set(key1, "value1");
    console.log(weakMap.get(key1)); // "value1"

```

### Вопрос: В каких случаях предпочтительнее использовать WeakSet и WeakMap?
### Ответ:
**WeakSet:**
- Когда нужно отслеживать объекты, которые могут быть собраны сборщиком мусора.
- Идеально подходит для временных коллекций объектов.

**WeakMap:**
- Когда ключи коллекции могут быть объектами, и их значения должны освобождаться автоматически, если ключ больше не используется.
- Часто применяется для хранения метаданных объектов.
#### Пример:
```javascript

    // Пример использования WeakMap для хранения метаданных
    const metadata = new WeakMap();
    const obj = { id: 1 };
    metadata.set(obj, { createdAt: Date.now() });
    console.log(metadata.get(obj)); // { createdAt: 123456789 }

```



___

## 8. Модули в JavaScript

### Вопрос: Назначение и концепция модуля/шаблона модуля?
### Ответ:
Модули в JavaScript представляют собой фрагменты кода, предназначенные для разбиения программы на отдельные компоненты. Они позволяют организовывать код, повторно использовать его и поддерживать чистоту структуры проекта. Основные преимущества модулей включают:

- повторное использование кода.
- улучшение читаемости и поддержки.
- инкапсуляция данных и функций.


### Вопрос: Какие типы модулей существуют в JavaScript?
### Ответ:
Существуют несколько стандартов модулей в JavaScript:

- **AMD (Asynchronous Module Definition):** используется в библиотеках, таких как RequireJS, для асинхронной загрузки модулей.
- **CommonJS:** стандарт, используемый в Node.js, где модули загружаются синхронно.
- **UMD (Universal module Definition):** универсальный формат, совместимый с различными системами модулей.
- **ES6 Modules:** современный стандарт модулей, встроенный в JavaScript начиная с ES6.

### Вопрос: Какой синтаксис используется для работы с модулями в ES6?
### Ответ:
В ES6-модулях применяются следующие конструкции:

- Экспорт по умолчанию:
```javascript

    export default function greet() {
      console.log('Hello!');
    }

```
- Именованный экспорт:
```javascript

    export const PI = 3.14;
    export function areaOfCircle(r) {
      return PI * r * r;
    }

```


- Импорт:
```javascript

    import greet from './greet.js';
    import { PI, areaOfCircle } from './math.js';- 

```

### Вопрос: Как работает динамический импорт в JavaScript?
### Ответ:
Динамический импорт позволяет загружать модули асинхронно во время выполнения программы. Это полезно, когда нужно загрузить модуль только при определенных условиях.

#### Пример:
```javascript

    async function loadModule() {
      try {
        const module = await import('./math.js');
        console.log(module.areaOfCircle(5));
      } catch (error) {
        console.error(error);
      }
    }
    loadModule();

```
___

## 9. Функциональные Паттерны

### Вопрос: Что такое обратные вызовы (callbacks) и как они работают?
### Ответ:
Обратный вызов — это функция, передаваемая в другую функцию в качестве аргумента, которая выполняется после завершения основной операции. Обратные вызовы широко используются в асинхронном программировании.

#### Пример:
```javascript

    // Эта функция имитирует асинхронную операцию с задержкой в 1 секунду
    function doSomethingAsync(cb) {
        setTimeout(function() {
            // После задержки выполняется обратный вызов с результатом
            cb('Result from async operation');
        }, 1000);
    }
    
    // Вызываем функцию с передачей обратного вызова
    doSomethingAsync(function(result) {
        // Вывод результата в консоль
        console.log(result); // Result from async operation
    });

```

### Вопрос: Какие проблемы возникают при использовании обратных вызовов?
### Ответ:
Основная проблема обратных вызовов — это так называемый "ад обратных вызовов" (callback hell), когда многоуровневые обратные вызовы делают код трудночитаемым и сложно управляемым.

#### Пример:
```javascript

    // Первая асинхронная операция
    function doFirst(cb) {
        setTimeout(function() {
            // Выполняем обратный вызов с первым результатом
            cb('first result');
        }, 500);
    }
    
    // Вторая асинхронная операция
    function doSecond(cb) {
        setTimeout(function() {
            // Выполняем обратный вызов со вторым результатом
            cb('second result');
        }, 300);
    }
    
    // Третья асинхронная операция
    function doThird(cb) {
        setTimeout(function() {
            // Выполняем обратный вызов с третьим результатом
            cb('third result');
        }, 200);
    }
    
    // Вызываем цепочку асинхронных операций с обратными вызовами
    doFirst(function(firstResult) {
        // Выводим результат первой операции
        console.log(firstResult);
    
        // Запускаем вторую операцию после первой
        doSecond(function(secondResult) {
            // Выводим результат второй операции
            console.log(secondResult);
    
            // Запускаем третью операцию после второй
            doThird(function(thirdResult) {
                // Выводим результат третьей операции
                console.log(thirdResult);
            });
        });
    });

```

### Вопрос: Что такое немедленное выполнение функции (IIFE) и зачем оно нужно?
### Ответ:
IIFE (Immediately Invoked Function Expression) — это функция, которая выполняется сразу после её объявления. Она полезна для изоляции переменных и предотвращения загрязнения глобальной области видимости.

#### Пример:
```javascript

    // Немедленно вызываемая функция с приватной переменной
    (function() {
        // Переменная privateVariable видима только внутри функции
        let privateVariable = 'This variable is private';
        // Выводим значение приватной переменной
        console.log(privateVariable);
    })();

```

### Вопрос: Что такое каррирование функций и частичные функции?
### Ответ:
Каррирование — это техника преобразования функции с несколькими аргументами в последовательность функций, каждая из которых принимает один аргумент. Частичная функция — это функция, созданная путем фиксации одного или нескольких аргументов другой функции.

#### Пример каррирования:
```javascript

    // Простая функция сложения двух чисел
    function add(a, b) {
        return a + b;
    }
    
    // Каррированная версия функции add
    function curriedAdd(a) {
        return function(b) {
            // Возвращаем результат сложения фиксированного аргумента a и аргумента b
            return add(a, b);
        };
    }
    
    // Создаем функцию addFive, которая прибавляет 5 к своему аргументу
    const addFive = curriedAdd(5);
    // Выводим результат сложения 5 и 7
    console.log(addFive(7)); // 12

```

#### Пример частичной функции:
```javascript

    // Функция для создания частичных функций
    function partial(fn, ...fixedArgs) {
        return function(...remainingArgs) {
            // Применяем функцию fn к объединенным аргументам
            return fn.apply(null, fixedArgs.concat(remainingArgs));
        };
    }
    
    // Создаем частичную функцию addPartial, которая прибавляет 5 к своему аргументу
    const addPartial = partial(add, 5);
    // Выводим результат сложения 5 и 7
    console.log(addPartial(7)); // 12

```

#### Пример частичной функции через bind:
```javascript

    // Простая функция сложения двух чисел
    function add(a, b) {
        return a + b;
    }
    
    // Создаем частичную функцию addFive с помощью bind
    const addFive = add.bind(null, 5);
    
    // Выводим результат сложения 5 и 7
    console.log(addFive(7)); // 12

```
___

## 10.Объектно-ориентированное программирование (ООП)

### Вопрос: Что такое ключевое слово new и как оно работает?
### Ответ:
Ключевое слово new используется для создания нового экземпляра объекта. Оно вызывает конструктор функции, создавая новое пространство памяти для объекта и связывая его с прототипом функции-конструктора.

#### Пример:
```javascript

    function Person(name) {
        this.name = name;
    }
    
    const john = new Person('John');
    console.log(john.name); // 'John'

```

### Вопрос: Что такое функции-конструкторы и их свойства?
### Ответ:
Функции-конструкторы — это специальные функции, используемые для создания новых объектов. Они определяют свойства и методы, которые будут унаследованы всеми экземплярами объекта.

#### Пример:
```javascript

    function Car(model, year) {
        this.model = model;
        this.year = year;
    }
    
    Car.prototype.getInfo = function() {
        return `This car is a ${this.model} from ${this.year}.`;
    };
    
    const tesla = new Car('Model S', 2018);
    console.log(tesla.getInfo()); // This car is a Model S from 2018.

```

### Вопрос: Как объявляются классы в ECMAScript?
### Ответ:
Классы в ECMAScript объявляются с помощью ключевого слова class. Внутри класса можно определить конструктор, методы и геттеры/сеттеры.

#### Пример:
```javascript

    class Vehicle {
     constructor(make, model) {
            this.make = make;
            this.model = model;
        }
    
        getFullName() {
            return `${this.make} ${this.model}`;
        }
    }
    
    const car = new Vehicle('Toyota', 'Camry');
    console.log(car.getFullName()); // Toyota Camry

```

### Вопрос: Какие бывают публичные, частные и статические элементы в ООП?
### Ответ:
- Публичные элементы доступны снаружи объекта.
- Частные элементы скрыты внутри объекта и доступны только внутри самого объекта.
- Статические элементы принадлежат классу, а не конкретному экземпляру объекта.

#### Пример:
```javascript

    class Animal {
        #privateField = 'Private'; // Частное поле
        publicField = 'Public'; // Публичное поле
    
        static staticMethod() { // Статический метод
            return 'Static Method';
        }
    
        getPrivateField() { // Метод для доступа к частному полю
            return this.#privateField;
        }
    }
    
    const dog = new Animal();
    console.log(dog.publicField); // Public
    console.log(dog.getPrivateField()); // Private
    console.log(Animal.staticMethod()); // Static Method

```

### Вопрос: В чем разница между классами и функциями-конструкторами?
### Ответ:
Основное отличие заключается в синтаксисе и семантике. Классы предлагают более удобный и современный синтаксис для определения объектов, наследования и работы с прототипами.

#### Пример:
```javascript

    // Функция-конструктор
    function Book(title, author) {
        this.title = title;
        this.author = author;
    }
    Book.prototype.getDetails = function() {
        return `${this.title} by ${this.author}`;
    };
    
    // Класс
    class BookClass {
        constructor(title, author) {
            this.title = title;
            this.author = author;
        }
    
        getDetails() {
            return `${this.title} by ${this.author}`;
        }
    }
    
    const book1 = new Book('Harry Potter', 'J.K. Rowling');
    const book2 = new BookClass('The Lord of the Rings', 'J.R.R. Tolkien');
    
    console.log(book1.getDetails()); // Harry Potter by J.K. Rowling
    console.log(book2.getDetails()); // The Lord of the Rings by J.R.R. Tolkien

```

### Вопрос: Как используется super() в классах?
### Ответ:
super() используется для вызова конструктора или методов родительского класса. Это полезно при наследовании.

#### Пример:
```javascript

    class Car extends Vehicle {
        constructor(make, model, color) {
            super(make, model);
            this.color = color;
        }
    
        getDescription() {
            return `${super.getFullName()} in ${this.color}`;
        }
    }
    
    const car = new Car('Toyota', 'Camry', 'Blue');
    console.log(car.getDescription()); // Toyota Camry in Blue

```

### Вопрос: Что такое прототипное наследование в JavaScript?
### Ответ:
Прототипное наследование — это механизм, посредством которого объекты получают доступ к свойствам и методам другого объекта через цепочку прототипов. В JavaScript каждый объект имеет внутренний скрытый объект-прототип, который ссылается на другой объект. Если свойство или метод не найдено в самом объекте, поиск продолжается в его прототипе и далее по цепочке.

### Вопрос: В чем разница между __ proto __ и prototype?
### Ответ:
- **__ proto __** — это свойство объекта, которое указывает на его прототип. Это ссылка на объект, от которого объект наследует свойства и методы.
- **prototype** — это свойство функции-конструктора, которое используется для установки прототипа создаваемых ею объектов. Все объекты, созданные с помощью данной функции-конструктора, будут иметь ссылку на этот прототип.
#### Пример:
```javascript

    function Person(name) {
        this.name = name;
    }
    Person.prototype.sayHello = function() {
        console.log(`Hello, my name is ${this.name}`);
    };
    
    const john = new Person('John');
    john.sayHello(); // Hello, my name is John
    
    console.log(Person.prototype === john.__proto__); // true

```

### Вопрос: Как использовать Object.create() для явного определения прототипов?
### Ответ:
Метод Object.create() позволяет создать новый объект с указанным прототипом. Это полезный способ создания объектов без использования функции-конструктора.

#### Пример:
```javascript

    const animalPrototype = {
        makeSound: function() {
            console.log('Making sound...');
        }
    };
    
    const cat = Object.create(animalPrototype);
    cat.makeSound(); // Making sound...
    
    console.log(cat.__proto__ === animalPrototype); // true

```
___

## 11. Ошибки JavaScript

### Вопрос: Как обрабатываются ошибки в JavaScript с помощью try..catch?
### Ответ:
Конструкция try..catch используется для перехвата и обработки исключений в JavaScript. Блок try содержит код, который может вызвать исключение, а блок catch перехватывает и обрабатывает возникшие исключения.

#### Пример:
```javascript

    try {
        // Возможный код с ошибкой
        nonExistentFunction();
    } catch (err) {
        // Обрабатываем ошибку
        console.error('An error occurred:', err.message);
    }

```

### Вопрос: Как реализовать пользовательские ошибки в JavaScript?
### Ответ:
Пользовательские ошибки создаются с помощью класса Error или его подклассов. Это позволяет создавать собственные типы ошибок с дополнительными данными.

#### Пример:
```javascript

    class CustomError extends Error {
        constructor(message) {
            super(message);
            this.name = 'CustomError';
        }
    }
    
    try {
        throw new CustomError('This is a custom error message.');
    } catch (err) {
        console.error(err.name, ':', err.message);
    }

```
___

## Продвинутый ECMAScript

### Вопрос: Что такое обещания (promises) в JavaScript?
### Ответ:
Обещания (promises) — это объекты, представляющие результат асинхронной операции. Они могут находиться в одном из трех состояний:

- Pending (ожидание): Промис еще не выполнен и не отклонен.
- Fulfilled (выполнено): Промис успешно завершился и вернул значение.
- Rejected (отклонено): Промис завершился неудачно и вернул причину отказа.

Основные методы обещаний:
- then(successCallback, failureCallback): Позволяет зарегистрировать обработчики успешного выполнения и отклонения промиса.
- catch(failureCallback): Регистрирует обработчик отклонения промиса.
- finally(onFinally): Регистрирует обработчик, который будет вызван независимо от успеха или отказа промиса.

#### Пример:
```javascript

    const promise = new Promise((resolve, reject) => {
        setTimeout(() => resolve('Resolved'), 1000);
    });
    
    promise.then(
        value => console.log(value), // 'Resolved'
        error => console.error(error)
    );
    
    promise.catch(error => console.error(error));
    
    promise.finally(() => console.log('Finally'));

```

### Вопрос: Какие таймеры доступны в JavaScript?
### Ответ:
В JavaScript доступны два основных типа таймеров:

- setTimeout: Устанавливает однократовый таймер, который вызывает указанную функцию через определенное время.
- setInterval: Устанавливает периодический таймер, который вызывает указанную функцию через регулярные интервалы времени.

#### Пример:
```javascript

    // Однократовый таймер
    setTimeout(() => {
        console.log('Timer fired after 1 second');
    }, 1000);
    
    // Периодический таймер
    const intervalId = setInterval(() => {
        console.log('Interval timer fired');
    }, 2000);
    
    // Остановка периодического таймера
    clearInterval(intervalId);

```

### Вопрос: Что такое Fetch API и как он работает?
### Ответ:
Fetch API — это современный способ выполнения сетевых запросов в JavaScript. Он основан на промисах и предоставляет удобный интерфейс для отправки HTTP-запросов и обработки ответов.

#### Пример:
```javascript

    fetch('https://example.com/api/data')
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => console.log(data))
        .catch(error => console.error('There has been a problem with your fetch operation:', error));

```

### Вопрос: Как работают async/await в JavaScript?
### Ответ:
Ключевые слова async и await позволяют писать асинхронный код в синхронном стиле, упрощая чтение и поддержание кода.

- async: Помечает функцию как асинхронную, возвращающую промис.
- await: Ожидает разрешения промиса, позволяя приостановить выполнение функции до получения результата.

#### Пример:
```javascript

    async function fetchData() {
        const response = await fetch('https://example.com/data');
        const data = await response.json();
        return data;
    }
    
    fetchData().then(data => console.log(data));

```

### Вопрос: Как работает цикл событий в JavaScript?
### Ответ:
Цикл событий (event loop) — это механизм, управляющий выполнением асинхронных задач в JavaScript. Он отвечает за планирование и выполнение задач в правильном порядке.

Компоненты цикла событий:
- **Call Stack:** Стек вызовов, содержащий функции, ожидающие выполнения.
- **Web APIs:** Внешние библиотеки, такие как setTimeout, XMLHttpRequest, и др., которые выполняют асинхронные задачи.
- **Task Queue:** Очередь задач, куда помещаются выполненные асинхронные задачи для последующего выполнения.
- **Microtask Queue:** Очередь микрозадач, где находятся задачи, которые должны быть выполнены немедленно после текущего выполнения.

Приоритеты:
- Микрозадачи имеют высший приоритет и выполняются до макрозадач.
- Макрозадачи (например, setTimeout) выполняются после очистки стека вызовов и очереди микрозадач.
- Пример:

#### Пример:
```javascript

    console.log('Start');
    
    setTimeout(() => {
        console.log('Timeout');
    }, 0);
    
    Promise.resolve().then(() => {
        console.log('Promise');
    });
    
    console.log('End');
    
    // Output:
    // Start
    // End
    // Promise
    // Timeout

```

### Вопрос: Что такое сборка мусора в JavaScript?
### Ответ:
Сборка мусора — это автоматический процесс освобождения памяти, занимаемой объектами, которые больше не используются. В JavaScript сборщик мусора автоматически освобождает память, когда объект становится недоступным.

Как работает сборка мусора:
- Маркер (Mark): Сборщик проходит по всем доступным объектам и помечает их как "живые".
- Очистка (Sweep): Все непомеченные объекты считаются ненужными и удаляются.

#### Пример:
```javascript

    let obj = { prop: 'value' };
    obj = null; // Объект больше не используется и будет собран сборщиком мусора

```

___

## 12. Хранение данных в браузере

### Вопрос: Чем localStorage отличается от sessionStorage?
### Ответ:
- **localStorage:** Данные сохраняются после закрытия браузера.
- **sessionStorage:** Данные удаляются при закрытии вкладки.

### Вопрос: Что такое Cookie, и чем они отличаются от localStorage?
### Ответ:
- **Cookie** — для хранения небольших данных (до 4 КБ), которые сервер может читать/записывать.
- **localStorage** — только для клиентского хранения (сервер не имеет доступа).

### Особенности Cookie:
- **Срок жизни:** Устанавливается вручную (max-age или expires).
- **Автоматическая отправка:** Прикрепляются к каждому HTTP-запросу (заголовок Cookie).
- **Безопасность:** Можно ограничить HttpOnly (запрет доступа через JavaScript) и Secure (только HTTPS).

#### Пример:
```javascript

    document.cookie = 'username=John; max-age=3600; path=/'; // Куки на 1 час
    
```

### Вопрос: Какие ограничения и вопросы безопасности связаны с localStorage и sessionStorage?
### Ответ:
Оба хранилища (localStorage и sessionStorage) имеют общие ограничения и риски:

- **размер данных:** максимум 5 МБ на домен.
- **безопасность:** данные хранятся в открытом виде и могут быть легко прочитаны любым скриптом на странице.
- **XSS уязвимости:** несанкционированный доступ через XSS атаки.
- **совместимость:** могут не поддерживаться старыми браузерами.

---

#### Пример защиты данных:

```javascript

    // Шифрование данных перед сохранением
    const encryptedData = encrypt(data);
    localStorage.setItem('key', encryptedData);

```



## Практические задачи

### Задача 1: Проверка палиндрома
### Условие:
Напишите функцию isPalindrome(str), которая проверяет, является ли строка палиндромом (читается одинаково слева направо и справа налево). Регистр символов игнорируется, пробелы и знаки препинания не учитываются.

### Пример:
- Вход: "raceCar" → Выход: true
- Вход: "hello" → Выход: false
- Вход: "A man, a plan, a canal: Panama" → Выход: true
### Одно из решений:
```javascript

    function isPalindrome(str) {
       
        const cleanStr = str.toLowerCase().replace(/[^a-z0-9]/g, '');
        let left = 0;
        let right = cleanStr.length - 1;
        
        while (left < right) {
            if (cleanStr[left++] !== cleanStr[right--]) {
                return false;
            }
        }
        return true;
    }  

    console.log(isPalindrome("raceCar")); // true
    console.log(isPalindrome("hello"));   // false
    console.log(isPalindrome("A man, a plan, a canal: Panama")); // true

```

### Задача 2: Найти наибольшее число в массиве
### Условие:
Напишите функцию findMax(arr), которая возвращает максимальное число в массиве целых чисел.

### Пример:
- Вход: [1, 3, 5, 7, 9] → Выход: 9
- Вход: [-5, -2, -10] → Выход: -2
### Одно из решений:
```javascript

    function findMax(arr) {
        if (arr.length === 0) return null;
        let max = arr[0];
        for (let num of arr) {
            if (num > max) max = num;
        }
        return max;
    }

    console.log(findMax([1, 3, 5, 7, 9])); // 9
    console.log(findMax([-5, -2, -10]));   // -2

```

### Задача 3: Обработка списка товаров с ценами
### Условие:
Напишите функцию calculateTotalPrice(items), которая рассчитывает общую стоимость товаров в массиве

### Пример:
- Вход:
```javascript

 [
    { name: "Apple", price: 50 },
    { name: "Banana", price: 20 },
    { name: "Cherry", price: 70 }
 ]

```
- Выход: 140

### Возможеное решение:
```javascript

    function calculateTotalPrice(items) {
        return items.reduce((total, item) => total + item.price, 0);
    }
    
    const products = [
        { name: "Apple", price: 50 },
        { name: "Banana", price: 20 },
        { name: "Cherry", price: 70 }
    ];
    
    console.log(calculateTotalPrice(products)); // 140

```


### Задача 4: Загрузка данных с нескольких источников
### Условие:
Напишите асинхронную функцию fetchMultipleUrls(urls), которая загружает данные с нескольких URL с помощью fetch и Promise.all, возвращая объединённый результат.

### Пример:
- Вход:
```javascript

    [
        'https://jsonplaceholder.typicode.com/users',
        'https://jsonplaceholder.typicode.com/posts'
    ]

```

- Выход: Массив, содержащий все пользователей и посты.

### Возможеное решение:
```javascript

    async function fetchMultipleUrls(urls) {
        try {
            const responses = await Promise.all(urls.map(url => 
                fetch(url).then(response => {
                    if (!response.ok) throw new Error(`Ошибка загрузки ${url}`);
                    return response.json();
                })
            ));
            return responses.flat(); // Объединяем массивы в один
        } catch (error) {
            console.error('Ошибка:', error);
            return [];
        }
    }
    
    // Пример использования
    fetchMultipleUrls([
        'https://jsonplaceholder.typicode.com/users',
        'https://jsonplaceholder.typicode.com/posts'
    ]).then(data => console.log('Данные:', data));

```
